"""
Web Exploitation Module
AI-powered web application exploitation
"""

import subprocess
import requests
import json
from modules.report_utils import append_section

def run(target, report_path=None, level='basic'):
    """Run AI-powered web exploitation against target."""
    print(f"[+] Starting AI-powered web exploitation against {target}")
    
    results = {
        'target': target,
        'level': level,
        'vulnerabilities': [],
        'exploits_attempted': [],
        'successful_exploits': [],
        'ai_analysis': {}
    }
    
    # AI analysis integration
    try:
        from modules.ai_engine import HackingAI
        ai_engine = HackingAI()
        if ai_engine.is_ai_available():
            target_info = {"target": target, "level": level, "type": "web"}
            ai_suggestions = ai_engine.suggest_exploitation_techniques(target, "web", target_info)
            results['ai_analysis'] = ai_suggestions
            print(f"[+] AI Suggestions: {ai_suggestions['ai_suggestions'].get('success_probability', 0.0)} success probability")
    except ImportError:
        print("[!] AI engine not available, continuing with standard exploitation")
    
    # Basic web reconnaissance
    print("[*] Running web reconnaissance...")
    
    # Check if target is accessible
    try:
        response = requests.get(f"http://{target}", timeout=10, allow_redirects=True)
        results['web_access'] = {
            'status_code': response.status_code,
            'server': response.headers.get('Server', 'Unknown'),
            'technologies': detect_technologies(response),
            'final_url': response.url
        }
        print(f"[+] Web access confirmed: {response.status_code} - {response.headers.get('Server', 'Unknown')}")
    except requests.RequestException as e:
        results['web_access'] = {
            'status': 'failed',
            'error': str(e)
        }
        print(f"[!] Web access failed: {e}")
        return results
    
    # HTTPS check
    try:
        response = requests.get(f"https://{target}", timeout=10, allow_redirects=True, verify=False)
        results['https_access'] = {
            'status_code': response.status_code,
            'server': response.headers.get('Server', 'Unknown'),
            'ssl_info': get_ssl_info(target)
        }
        print(f"[+] HTTPS access confirmed: {response.status_code}")
    except requests.RequestException as e:
        results['https_access'] = {
            'status': 'failed',
            'error': str(e)
        }
        print(f"[!] HTTPS access failed: {e}")
    
    # Basic web exploitation
    print("[*] Running basic web exploitation...")
    
    # Directory enumeration
    if level in ['basic', 'intermediate', 'advanced', 'stealth']:
        common_dirs = ['admin', 'login', 'wp-admin', 'phpmyadmin', 'config', 'backup', 'test']
        for directory in common_dirs:
            try:
                response = requests.get(f"http://{target}/{directory}", timeout=5)
                if response.status_code == 200:
                    results['vulnerabilities'].append({
                        'type': 'directory_discovery',
                        'path': f"/{directory}",
                        'status_code': response.status_code,
                        'severity': 'medium'
                    })
                    print(f"[+] Found accessible directory: /{directory}")
            except:
                continue
    
    # Common web vulnerabilities
    if level in ['intermediate', 'advanced', 'stealth']:
        print("[*] Running intermediate web exploitation...")
        
        # SQL Injection test (basic)
        sql_payloads = ["'", "1' OR '1'='1", "1; DROP TABLE users--"]
        for payload in sql_payloads:
            try:
                response = requests.get(f"http://{target}/?id={payload}", timeout=5)
                if any(error in response.text.lower() for error in ['sql', 'mysql', 'oracle', 'syntax error']):
                    results['vulnerabilities'].append({
                        'type': 'sql_injection',
                        'payload': payload,
                        'evidence': 'SQL error detected',
                        'severity': 'high'
                    })
                    print(f"[+] Potential SQL injection found with payload: {payload}")
            except:
                continue
        
        # XSS test (basic)
        xss_payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
        for payload in xss_payloads:
            try:
                response = requests.get(f"http://{target}/?search={payload}", timeout=5)
                if payload in response.text:
                    results['vulnerabilities'].append({
                        'type': 'xss',
                        'payload': payload,
                        'evidence': 'Payload reflected in response',
                        'severity': 'medium'
                    })
                    print(f"[+] Potential XSS found with payload: {payload}")
            except:
                continue
    
    # Advanced web exploitation
    if level in ['advanced', 'stealth']:
        print("[*] Running advanced web exploitation...")
        
        # Nikto scan
        try:
            nikto_result = run_nikto_scan(target)
            if nikto_result:
                results['nikto_scan'] = nikto_result
                print("[+] Nikto scan completed")
        except Exception as e:
            print(f"[!] Nikto scan failed: {e}")
        
        # Directory bruteforce (simulated)
        results['directory_bruteforce'] = {
            'status': 'simulated',
            'note': 'Directory bruteforce would be implemented here'
        }
        
        # CMS detection and exploitation
        cms_info = detect_cms(target)
        if cms_info:
            results['cms_detection'] = cms_info
            print(f"[+] CMS detected: {cms_info.get('type', 'Unknown')}")
    
    # Generate recommendations based on findings
    recommendations = []
    
    if results['vulnerabilities']:
        recommendations.append(f"Found {len(results['vulnerabilities'])} potential vulnerabilities")
        
        for vuln in results['vulnerabilities']:
            if vuln['type'] == 'sql_injection':
                recommendations.append("SQL injection vulnerability detected - implement input validation")
            elif vuln['type'] == 'xss':
                recommendations.append("XSS vulnerability detected - implement output encoding")
            elif vuln['type'] == 'directory_discovery':
                recommendations.append("Sensitive directories exposed - implement proper access controls")
    
    # Add AI-powered recommendations if available
    if 'ai_analysis' in results and results['ai_analysis']:
        ai_recommendations = results['ai_analysis'].get('ai_suggestions', {}).get('techniques', [])
        recommendations.extend(ai_recommendations)
    
    # Add to report
    if report_path:
        append_section(
            report_path,
            "AI-Powered Web Exploitation",
            f"Comprehensive web exploitation at {level} level using AI analysis",
            [
                f"nikto -h {target}",
                f"dirb http://{target}",
                f"sqlmap -u http://{target}",
                f"xsser --url http://{target}"
            ],
            {
                'vulnerabilities': results['vulnerabilities'],
                'web_access': results.get('web_access', {}),
                'https_access': results.get('https_access', {}),
                'exploits_attempted': len(results['exploits_attempted'])
            },
            [f"Level: {level}", f"Target: {target}", f"Vulnerabilities: {len(results['vulnerabilities'])}"],
            recommendations,
            results
        )
    
    print(f"[+] AI-powered web exploitation completed for {target}")
    print(f"[+] Found {len(results['vulnerabilities'])} potential vulnerabilities")
    return results

def detect_technologies(response):
    """Detect web technologies from response headers and content."""
    technologies = []
    
    # Server detection
    server = response.headers.get('Server', '')
    if server:
        technologies.append(f"Server: {server}")
    
    # Framework detection
    if 'X-Powered-By' in response.headers:
        technologies.append(f"Framework: {response.headers['X-Powered-By']}")
    
    # Content analysis
    content = response.text.lower()
    if 'wordpress' in content:
        technologies.append("CMS: WordPress")
    elif 'drupal' in content:
        technologies.append("CMS: Drupal")
    elif 'joomla' in content:
        technologies.append("CMS: Joomla")
    
    if 'jquery' in content:
        technologies.append("JavaScript: jQuery")
    if 'bootstrap' in content:
        technologies.append("CSS: Bootstrap")
    
    return technologies

def get_ssl_info(target):
    """Get SSL certificate information."""
    try:
        import ssl
        import socket
        
        context = ssl.create_default_context()
        with socket.create_connection((target, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=target) as ssock:
                cert = ssock.getpeercert()
                return {
                    'subject': dict(x[0] for x in cert['subject']),
                    'issuer': dict(x[0] for x in cert['issuer']),
                    'version': cert['version'],
                    'serial_number': cert['serialNumber'],
                    'not_before': cert['notBefore'],
                    'not_after': cert['notAfter']
                }
    except:
        return None

def run_nikto_scan(target):
    """Run Nikto web vulnerability scanner."""
    try:
        cmd = ['nikto', '-h', target, '-Format', 'txt']
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        if result.returncode == 0:
            return {
                'status': 'success',
                'output': result.stdout,
                'target': target
            }
        else:
            return {
                'status': 'failed',
                'error': result.stderr
            }
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return {
            'status': 'not_available',
            'note': 'nikto command not available or timed out'
        }

def detect_cms(target):
    """Detect Content Management System."""
    try:
        response = requests.get(f"http://{target}", timeout=10)
        content = response.text.lower()
        
        if 'wordpress' in content or '/wp-content/' in content:
            return {'type': 'WordPress', 'confidence': 'high'}
        elif 'drupal' in content or '/sites/default/' in content:
            return {'type': 'Drupal', 'confidence': 'high'}
        elif 'joomla' in content or '/administrator/' in content:
            return {'type': 'Joomla', 'confidence': 'high'}
        else:
            return {'type': 'Unknown', 'confidence': 'low'}
    except:
        return None 